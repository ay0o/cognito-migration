import os
import boto3


try:
    source_app_client_id = os.environ['SOURCE_APP_CLIENT_ID']
    source_region = os.environ['SOURCE_REGION']
    source_role_arn = os.environ['SOURCE_ROLE_ARN']
    source_user_pool_id = os.environ['SOURCE_USER_POOL_ID']
except KeyError as e:
    raise SystemExit(f"[ERROR] Missing required variable: {e}")


def get_cognito_client():
    sts_client = boto3.client('sts')
    try:
        role = source_role_arn
        assumed_role = sts_client.assume_role(
            RoleArn=role,
            RoleSessionName='CognitoMigration'
        )
        credentials = assumed_role['Credentials']
        return boto3.client(
            'cognito-idp',
            region_name=source_region,
            aws_access_key_id=credentials['AccessKeyId'],
            aws_secret_access_key=credentials['SecretAccessKey'],
            aws_session_token=credentials['SessionToken']
        )
    except Exception as e:
        raise SystemExit(f"[ERROR] Could not assume the role {role}. Details: {e}")


def authenticate_user(cognito_client, username, password):
    try:
        cognito_client.admin_initiate_auth(
            UserPoolId=source_user_pool_id,
            ClientId=source_app_client_id,
            AuthFlow='ADMIN_USER_PASSWORD_AUTH',
            AuthParameters={
                'USERNAME': username,
                'PASSWORD': password
            }
        )
    # If credentials were wrong or the user does not exist, an exception is raised.
    except cognito_client.exceptions.NotAuthorizedException:
        raise SystemExit('[ERROR] The username or password is incorrect!')
    except cognito_client.exceptions.UserNotFoundException:
        raise SystemExit('[ERROR] The username does not exist!')
    except Exception as e:
        raise SystemExit(f"[ERROR] Could not authenticate user. Details: {e}")


def get_user_attributes(cognito_client, username):
    try:
        response = cognito_client.admin_get_user(
            UserPoolId=source_user_pool_id,
            Username=username
        )
        # Attributes need to be transformed into a regular dict, because the format of response['UserAttributes'] is a list of dicts [{'Name': name, 'Value': value}, ...]
        attributes = {'username': username}
        for attribute in response['UserAttributes']:
            # When the user attributes are fetched from the source, the `sub` is part of the response. `sub` is a random ID generated by Cognito when a user is created,
            # so the reponse can't have it because Cognito will generate a new one when the user is created in the destination.
            if attribute['Name'] != 'sub':
                attributes[attribute['Name']] = attribute['Value']
        return attributes
    except cognito_client.exceptions.UserNotFoundException:
        raise SystemExit(f"[ERROR] User {username} does not exist!")
    except Exception as e:
        raise SystemExit(f"[ERROR] Could not get user attributes! Details: {e}")


def lambda_handler(event, context):
    cognito_client = get_cognito_client()
    username = event['userName']
    user_attributes = get_user_attributes(cognito_client, username)
    event['response']['userAttributes'] = user_attributes
    event['response']['messageAction'] = 'SUPPRESS'

    # When a user signs in for the first time in the new pool, the Lambda will authenticate it in the older user pool and then migrate the user attributes.
    if event['triggerSource'] == "UserMigration_Authentication":
        authenticated_user = authenticate_user(cognito_client, username, event['request']['password'])
        if authenticated_user:
            event['response']['finalUserStatus'] = 'CONFIRMED'

    # When a user uses the forgot password feature but it still doesn't exist in the new pool, the user attributes are fetched from the old pool and the user is created in the new one.
    elif event['triggerSource'] == "UserMigration_ForgotPassword":
        event['response']['finalUserStatus'] = 'RESET_REQUIRED'

    return event
